🇶 Spring에서 AOP(Aspect Oriented Programming)가 필요한 이유와 이를 활용한 실제 애플리케이션 개발 사례에 대해 설명하세요.

AOP
AOP(Aspect-Oriented Programming)는 기존과 다른 프로그램 구조 사고 방식을 제공함으로써 객체 지향 프로그래밍(OOP)의 부족한 부분을 보완한다.

OOP의 모듈화의 핵심 단위는 클래스이고, AOP의 모듈화의 핵심 단위는 관점이다. Aspect는 여러 유형과 객체 간에 발생하는 문제 (ex - 트랜잭션)의 모듈화를 가능하게 한다.

AOP의 핵심 기능과 부가 기능
애플리케이션 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있다.

핵심 기능(Core Concerns)
객체가 제공하는 고유의 기능(업무 로직 등을 포함)이다.

부가 기능(CROSS-CUTTING CONCERNS)
핵심 기능을 보조하기 위해 제공되는 기능이다.
로그 추적 로직, 보안, 트랜잭션 기능 등이 있다.
단독으로 사용되지 않고 핵심 기능과 함께 사용된다.

AOP가 필요한 이유
소프트웨어 개발에서 변경 지점은 하나가 될 수 있도록 잘 모듈화 되어야 한다.

부가 기능처럼 특정 로직을 애플리케이션 전반에 적용하는 문제는 일반적인 OOP 방식으로는 해결이 어렵기 때문에 핵심 기능과 부가 기능을 분리하는 AOP 방식이 필요하다.

핵심내용
OOP 방식의 프로그래밍을 했을 때 여러 곳에서 공통적으로 사용되는 부가 기능의 중복 코드가 발생하게 된다. 이때 중복되는 부가 기능에 수정 및 삭제가 필요하게 되면 사용되는 모든 곳에 수정 및 삭제 동작을 해줘야한다. 관심 지향 프로그래밍(AOP)은 OOP 방식의 불필요한 반복을 해결하기 위한 방법이다.

스프링 AOP의 실제 적용 사례
스프링 AOP를 활용한 실제 적용 사례로는 로깅, 트랜잭션 관리, 보안 검사 등이 있다. 이러한 기능들은 애플리케이션의 여러 부분에서 공통적으로 필요하지만, 각각의 비즈니스 로직과는 독립적으로 관리되어야 하기 때문이다.

예를 들어, 로깅 Aspect를 구현하여 메소드의 실행 시간을 로그로 기록하는 경우, 아래와 같은 코드를 사용할 수 있다.

@Aspect
public class LoggingAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object proceed = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - start;
        logger.info(joinPoint.getSignature() + " executed in " + executionTime + "ms");
        return proceed;
    }
}
이 코드는 서비스 레이어의 모든 메소드 실행 전후에 실행 시간을 로그로 기록한다. @Around 어노테이션을 사용하여 메소드 실행 전후에 로그를 남기는 Advice를 정의하였다.

이 외에도 트랜잭션 관리나 보안 검사 등 다양한 공통 기능을 AOP를 통해 쉽게 구현할 수 있으며, 이는 애플리케이션의 코드를 깔끔하게 유지하고, 유지보수를 용이하게 한다.

🇶 Spring MVC에서 클라이언트의 요청 처리 흐름을 @Controller와 @RestController의 차이점을 중심으로 각각의 처리 과정과 특징을 포함하여 설명하세오.

전통적인 Spring MVC의 컨트롤러인 @Controller와 Restuful 웹서비스의 컨트롤러인 @RestController의 주요한 차이점은 HTTP Response Body가 생성되는 방식이다.

전통적인 Spring MVC의 컨트롤러인 @Controller는 주로 View를 반환하기 위해 사용한다. 아래와 같은 과정을 통해 Spring MVC Container는 Client의 요청으로부터 View를 반환한다.

흐름은 다음과 같다.

Client는 URI 형식으로 웹 서비스에 요청을 보낸다.
DispatcherServlet이 요청을 처리할 대상을 찾는다.
HandlerAdapter을 통해 요청을 Controller로 위임한다.
Controller는 요청을 처리한 후에 ViewName을 반환한다.
DispatcherServlet은 ViewResolver를 통해 ViewName에 해당하는 View를 찾아 사용자에게 반환한다.

Spring MVC의 컨트롤러를 사용하면서 Data를 반환해야 하는 경우도 있다. 컨트롤러에서는 데이터를 반환하기 위해 @ResponseBody 어노테이션을 활용해주어야 한다. 이를 통해 Controller도 Json 형태로 데이터를 반환할 수 있다.

이때의 흐름은 다음과 같다.

Client는 URI 형식으로 웹 서비스에 요청을 보낸다.
DispatcherServlet이 요청을 처리할 대상을 찾는다.
HandlerAdapter을 통해 요청을 Controller로 위임한다.
Controller는 요청을 처리한 후에 객체를 반환한다.
반환되는 객체는 Json으로 Serialize되어 사용자에게 반환된다.

@RestController는 @Controller에 @ResponseBody가 추가된 것이다. 당연하게도 RestController의 주용도는 Json 형태로 객체 데이터를 반환하는 것이다. 최근에 데이터를 응답으로 제공하는 REST API를 개발할 때 주로 사용하며 객체를 ResponseEntity로 감싸서 반환한다. 이러한 이유로 동작 과정 역시 @Controller에 @ReponseBody를 붙인 것과 완벽히 동일하다.

흐름은 다음과 같다.

Client는 URI 형식으로 웹 서비스에 요청을 보낸다.
DispatcherServlet이 요청을 처리할 대상을 찾는다.
HandlerAdapter을 통해 요청을 Controller로 위임한다.
Controller는 요청을 처리한 후에 객체를 반환한다.
반환되는 객체는 Json으로 Serialize되어 사용자에게 반환된다.
