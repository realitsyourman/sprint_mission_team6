🇶JPA에서 발생하는 N+1 문제의 발생 원인과 해결 방안에 대해 설명하세요.
JPA에서 발생하는 N+1 문제는 주로 연관된 엔티티들을 조회할 때 연관 관계를 처리하는 방식에서 발생한다. 기본적으로 JPA는 연관된 엔티티를 조회할 때 Lazy Loading을 사용하므로 연관된 엔티티를 필요할 때마다 각각 쿼리로 조회하게 된다. 이로 인해 다수의 쿼리가 실행되며 결국 조회한 엔티티 수에 비례하여 N+1개의 쿼리가 실행되는 문제가 발생한다.

예를 들어 부모 엔티티가 여러 개일 때 각 부모 엔티티에 연관된 자식 엔티티를 조회하려면 부모 엔티티에 대해 먼저 1개의 쿼리가 실행되고 그 후 자식 엔티티에 대해 N개의 추가 쿼리가 실행되므로 총 N+1개의 쿼리가 실행된다.

이 문제를 해결하는 방법은 크게 두 가지가 있다. 첫 번째는 fetch join을 사용하는 방법이다. fetch join을 사용하면 연관된 엔티티들을 한 번의 쿼리로 함께 조회할 수 있어 N+1 문제를 해결할 수 있다. 두 번째는 EntityGraph를 활용하는 방법으로 필요한 연관 관계를 미리 지정하여 함께 조회하는 방식이다. 또한 LAZY 대신 EAGER 로딩 전략을 사용할 수도 있지만 이는 성능에 부담을 줄 수 있기 때문에 신중하게 적용해야 한다.

따라서 N+1 문제를 해결하기 위해서는 쿼리 최적화 기법인 fetch join이나 EntityGraph를 사용하여 연관된 엔티티들을 한 번에 로딩하는 방법을 고려해야 한다.

🇶트랜잭션 ACID 속성 중 격리성(Isolation)이 보장되지 않을 때 발생할 수 있는 문제점들을 설명하고, 이를 해결하기 위한 트랜잭션 격리 수준들을 설명하세요.

트랜잭션 ACID 속성 중 격리성(Isolation)이 보장되지 않을 때 발생할 수 있는 문제점들은 주로 동시성 제어에서 발생한다. 격리성이 보장되지 않으면 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨지거나 예기치 않은 결과를 초래할 수 있다. 대표적인 문제점으로는 더티 읽기(Dirty Read), 비 반복 읽기(Non-repeatable Read), 팬텀 리드(Phantom Read) 가 있다.

    더티 읽기(Dirty Read): 한 트랜잭션이 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 때 발생한다. 이 경우 읽은 데이터가 실제로는 롤백될 수 있어, 잘못된 데이터를 기반으로 작업을 진행하게 된다.

    비 반복 읽기(Non-repeatable Read): 트랜잭션이 처음 읽은 데이터를 다시 읽었을 때 다른 트랜잭션에 의해 값이 변경된 경우 발생한다. 이로 인해 같은 데이터를 두 번 읽었지만 다른 값을 반환받게 되어 일관성이 깨진다.

    팬텀 리드(Phantom Read): 트랜잭션이 특정 조건에 맞는 데이터를 조회한 후 다른 트랜잭션에서 데이터를 삽입, 수정, 삭제하여 조회 결과가 변경되는 상황이다. 이로 인해 트랜잭션 내에서 처음과 끝의 조회 결과가 달라질 수 있다.

이 문제들을 해결하기 위해 트랜잭션의 격리 수준을 설정할 수 있으며, 각 격리 수준은 동시성 제어와 성능을 절충하는 방식이다. 대표적인 트랜잭션 격리 수준은 다음과 같다:

    READ UNCOMMITTED: 가장 낮은 격리 수준으로 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽을 수 있다. 이로 인해 더티 읽기, 비 반복 읽기, 팬텀 리드가 모두 발생할 수 있다. 성능은 좋지만 데이터 일관성이 보장되지 않는다.

    READ COMMITTED: 트랜잭션이 커밋된 데이터만 읽을 수 있도록 보장한다. 더티 읽기는 방지하지만 비 반복 읽기와 팬텀 리드는 여전히 발생할 수 있다. 일반적으로 사용되는 격리 수준이다.

    REPEATABLE READ: 트랜잭션이 처음 읽은 데이터를 다시 읽을 때 같은 값을 읽을 수 있도록 보장한다. 비 반복 읽기는 방지되지만 팬텀 리드는 여전히 발생할 수 있다.

    SERIALIZABLE: 가장 높은 격리 수준으로 트랜잭션들이 순차적으로 실행되도록 보장한다. 이 수준에서는 더티 읽기, 비 반복 읽기, 팬텀 리드를 모두 방지할 수 있다. 성능은 가장 낮지만 데이터 일관성은 가장 강력하게 보장된다.

따라서 격리성이 보장되지 않으면 동시 실행되는 트랜잭션들 간에 데이터의 일관성이 깨질 수 있으며 이를 해결하기 위해서는 적절한 트랜잭션 격리 수준을 설정하여 동시성 문제를 해결해야 한다.
