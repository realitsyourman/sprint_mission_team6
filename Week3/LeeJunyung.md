## 🇶JPA에서 발생하는 N+1 문제의 발생 원인과 해결 방안에 대해 설명하세요.
#### 📌 N+1문제란? 
: 연관관계가 설정된 엔티티를 조회할 경우, 조회된 데이터갯수(n)만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상
즉, 1번의 쿼리를 날렸을 때, 의도하지 않은 N번의 쿼리가 추가적으로 실행되는것을 의미한다.

#### 📍 발생 이유 
N+1이 발생하는 이유는 JPA가 JPQL을 분석해서 SQL을 생성할 때 Fetch 전략을 참고하지 않고, 오직 JPQL 자체만을 사용한다.
- JPA Repository를 활용해 인터페이스 메소드를 호출할 때 발생한다.
- 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생한다.
- JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우 발생한다
- JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후 연관관계인 하위 엔티티를 다시 조회하는 경우에 발생한다.
- JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에 발생한다.
- JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPAL만 가지고 SQL을 생성하기 때문에 발생한다.

  
1. Fetch 전략이 즉시 로딩인 경우
   ```
   1. findAll()을 한 순간 select t from Team t 이라는 JPQL 구문이 생성되고 해당 구문을 분석한 select * from team 이라는 SQL이 생성되어 실행된다.
   2. DB의 결과를 받아 team 엔티티의 인스턴스들을 생성한다.
   3. team과 연관되어 있는 user도 로딩을 해야 한다.
   4. 영속성 컨텍스트에서 연관된 user가 있는지 확인한다.
   5. 영속성 컨텍스트에 없다면 2에서 만들어진 team 인스턴스 개수에 맞게 select * from user where team id = ? 이라는 SQL 구문이 생성된다. (N+1이 발생함) 
   ```
2. Fetch 전략이 지연 로딩인 경우
   ```
   1. findAll()을 한 순간 select t from Team t 이라는 JPQL 구문이 생성되고, 해당 구문을 분석한 select * from team 이라는 SQL이 생성되어 실행한다.
   2. DB의 결과를 받아 team 엔티티의 인스턴스들을 생성한다.
   3. 코드 중 team의 user 객체를 사용하려고 하는 시점에 영속성 컨텍스트에서 연관된 user가 있는지 확인한다.
   4. 영속성 컨텍스트에 없다면 2에서 만들어진 team 인스턴스들 개수에 맞게 select * from user where team_id=? 이라는 SQL 구문이 생성된다. (N+1 이 발생됨) 
   ```

#### ✅ 해결방안 
: N+1을 해결하기 위해서는 Fetch Join, EntityGraph 어노테이션, Batch Size 등의 방법을 주로 사용한다. 
N+1 문제가 발생하는 이유는 즉, 한쪽 테이블만을 조회하고 연결된 다른 테이블은 따로 조회하기 때문이다. 
이미 두 테이블을 JOIN 해 한번에 모든 데이터를 가져올 수 있으면 N+1이 발생하지 않을 수 있다.(=fetch join)

##### 1. Fetch Join 
JPQL을 사용해 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법 (= SQL JOIN문과 비슷)

즉, 별도의 메소드를 만들어 @Query 어노테이션을 사용해 "join fetch 엔티티.연관관계_엔티티" 구문을 만들어 사용한다. 

##### 2. EntityGraph 어노테이션
@EntityGraph 라는 어노테이션을 사용해서 fetch 조인을 하는 것인데, 자주 사용하지 않고, 조금만 관계가 복잡해도 로직이 복잡해지고 어려워져 자주 사용하지 않는다. 

##### 3. Batch Size
N+1 문제가 안 일어나게 하는 방법이 아닌, 문제가 발생하더라도 select * from user where team_id = ? 가 아닌, select * from user where team_id in (?, ?, ?) 방식으로 N+1 문제가 발생하게 하도록 하는 방법이며, 
이렇게 하면 100번 일어날 N+1 문제를 1번만 더 조회하는 방식으로 성능을 최적화시킬 수 있는 방법이다. 
```
## application.yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size : 1000  //batch size 설정
```
----------

###### (추가내용) ✚ 실무에서 N+1 문제로 DB가 죽어버리는 문제를 방지 하기 위한 방안
연관관계에 대한 설정이 필요하다면 FetchType을 성능 최적화 하기 어려운 즉시 로딩이 아닌, 지연 로딩 모드로 사용하며, 
성능 최적화가 필요하다면 Fetch 조인을 사용한다. 
또한, 기본적으로 BatchSize를 1000 이하로 설정한다. 

## 🇶트랜잭션 ACID 속성 중 격리성(Isolation)이 보장되지 않을 때 발생할 수 있는 문제점들을 설명하고, 이를 해결하기 위한 트랜잭션 격리 수준들을 설명하세요.
